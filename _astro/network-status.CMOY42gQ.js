import{e as Q,l as F,c as R,d as j,g as z,h as N}from"./progress.isgvytKC.js";import{c as k,b as B}from"./store.CLE7GteW.js";const p=(t,e)=>e.some(n=>t instanceof n);let E,v;function q(){return E||(E=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function U(){return v||(v=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const b=new WeakMap,m=new WeakMap,w=new WeakMap;function V(t){const e=new Promise((n,s)=>{const r=()=>{t.removeEventListener("success",a),t.removeEventListener("error",i)},a=()=>{n(g(t.result)),r()},i=()=>{s(t.error),r()};t.addEventListener("success",a),t.addEventListener("error",i)});return w.set(e,t),e}function W(t){if(b.has(t))return;const e=new Promise((n,s)=>{const r=()=>{t.removeEventListener("complete",a),t.removeEventListener("error",i),t.removeEventListener("abort",i)},a=()=>{n(),r()},i=()=>{s(t.error||new DOMException("AbortError","AbortError")),r()};t.addEventListener("complete",a),t.addEventListener("error",i),t.addEventListener("abort",i)});b.set(t,e)}let C={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return b.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return g(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function T(t){C=t(C)}function _(t){return U().includes(t)?function(...e){return t.apply(D(this),e),g(this.request)}:function(...e){return g(t.apply(D(this),e))}}function K(t){return typeof t=="function"?_(t):(t instanceof IDBTransaction&&W(t),p(t,q())?new Proxy(t,C):t)}function g(t){if(t instanceof IDBRequest)return V(t);if(m.has(t))return m.get(t);const e=K(t);return e!==t&&(m.set(t,e),w.set(e,t)),e}const D=t=>w.get(t);function G(t,e,{blocked:n,upgrade:s,blocking:r,terminated:a}={}){const i=indexedDB.open(t,e),u=g(i);return s&&i.addEventListener("upgradeneeded",c=>{s(g(i.result),c.oldVersion,c.newVersion,g(i.transaction),c)}),n&&i.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),u.then(c=>{a&&c.addEventListener("close",()=>a()),r&&c.addEventListener("versionchange",d=>r(d.oldVersion,d.newVersion,d))}).catch(()=>{}),u}const H=["get","getKey","getAll","getAllKeys","count"],J=["put","add","delete","clear"],S=new Map;function M(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(S.get(e))return S.get(e);const n=e.replace(/FromIndex$/,""),s=e!==n,r=J.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(r||H.includes(n)))return;const a=async function(i,...u){const c=this.transaction(i,r?"readwrite":"readonly");let d=c.store;return s&&(d=d.index(u.shift())),(await Promise.all([d[n](...u),r&&c.done]))[0]};return S.set(e,a),a}T(t=>({...t,get:(e,n,s)=>M(e,n)||t.get(e,n,s),has:(e,n)=>!!M(e,n)||t.has(e,n)}));const X=["continue","continuePrimaryKey","advance"],I={},x=new WeakMap,O=new WeakMap,Y={get(t,e){if(!X.includes(e))return t[e];let n=I[e];return n||(n=I[e]=function(...s){x.set(this,O.get(this)[e](...s))}),n}};async function*Z(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const n=new Proxy(e,Y);for(O.set(n,e),w.set(n,D(e));e;)yield n,e=await(x.get(n)||e.continue()),x.delete(n)}function A(t,e){return e===Symbol.asyncIterator&&p(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&p(t,[IDBIndex,IDBObjectStore])}T(t=>({...t,get(e,n,s){return A(e,n)?Z:t.get(e,n,s)},has(e,n){return A(e,n)||t.has(e,n)}}));const ee="arithmetic-practice-offline",te=1;class o extends Error{constructor(e,n,s){super(`Storage error during ${n}: ${e}`),this.operation=n,this.cause=s,this.name="StorageError"}}class ne{dbPromise=null;async init(){if(!this.dbPromise)try{this.dbPromise=G(ee,te,{upgrade(e,n,s,r){if(console.log("[Storage] Upgrading database from version",n,"to",s),!e.objectStoreNames.contains("exercises")){const a=e.createObjectStore("exercises",{keyPath:"instance.id"});a.createIndex("generatedAt","generatedAt"),a.createIndex("used","used"),console.log("[Storage] Created exercises store")}if(!e.objectStoreNames.contains("syncQueue")){const a=e.createObjectStore("syncQueue",{keyPath:"id",autoIncrement:!0});a.createIndex("timestamp","timestamp"),a.createIndex("type","type"),console.log("[Storage] Created syncQueue store")}e.objectStoreNames.contains("progressCache")||(e.createObjectStore("progressCache"),console.log("[Storage] Created progressCache store")),e.objectStoreNames.contains("preferences")||(e.createObjectStore("preferences",{keyPath:"key"}),console.log("[Storage] Created preferences store"))},blocked(){console.warn("[Storage] Database upgrade blocked - close other tabs")},blocking(){console.warn("[Storage] This tab is blocking a database upgrade")}}),await this.dbPromise,console.log("[Storage] Database initialized successfully")}catch(e){throw console.error("[Storage] Database initialization failed:",e),this.dbPromise=null,new o("Failed to initialize database","init",e)}}async getDB(){return this.dbPromise||await this.init(),this.dbPromise}static isAvailable(){try{return typeof indexedDB<"u"}catch{return!1}}async close(){this.dbPromise&&((await this.dbPromise).close(),this.dbPromise=null,console.log("[Storage] Database connection closed"))}async clearAll(){try{const n=(await this.getDB()).transaction(["exercises","syncQueue","progressCache","preferences"],"readwrite");await Promise.all([n.objectStore("exercises").clear(),n.objectStore("syncQueue").clear(),n.objectStore("progressCache").clear(),n.objectStore("preferences").clear()]),await n.done,console.log("[Storage] All stores cleared")}catch(e){throw new o("Failed to clear all stores","clearAll",e)}}async addExercise(e){try{const n=await this.getDB(),s={instance:e,generatedAt:new Date,used:!1};await n.put("exercises",s)}catch(n){throw new o(`Failed to add exercise ${e.id}`,"addExercise",n)}}async getExercise(e){try{return await(await this.getDB()).get("exercises",e)}catch(n){throw new o(`Failed to get exercise ${e}`,"getExercise",n)}}async getUnusedExercises(){try{return(await(await this.getDB()).getAll("exercises")).filter(s=>!s.used)}catch(e){throw new o("Failed to get unused exercises","getUnusedExercises",e)}}async markExerciseUsed(e){try{const n=await this.getDB(),s=await n.get("exercises",e);s&&(s.used=!0,await n.put("exercises",s))}catch(n){throw new o(`Failed to mark exercise ${e} as used`,"markExerciseUsed",n)}}async clearExercises(){try{await(await this.getDB()).clear("exercises")}catch(e){throw new o("Failed to clear exercises","clearExercises",e)}}async getExerciseCount(){try{const e=await this.getDB(),n=await e.count("exercises"),r=(await e.getAll("exercises")).filter(a=>!a.used).length;return{total:n,unused:r}}catch(e){throw new o("Failed to get exercise count","getExerciseCount",e)}}async addToSyncQueue(e){try{return await(await this.getDB()).add("syncQueue",e)}catch(n){throw new o("Failed to add item to sync queue","addToSyncQueue",n)}}async getAllSyncQueue(){try{return await(await this.getDB()).getAll("syncQueue")}catch(e){throw new o("Failed to get all sync queue items","getAllSyncQueue",e)}}async getSyncQueueByType(e){try{return await(await this.getDB()).transaction("syncQueue").store.index("type").getAll(e)}catch(n){throw new o(`Failed to get sync queue items of type ${e}`,"getSyncQueueByType",n)}}async removeFromSyncQueue(e){try{await(await this.getDB()).delete("syncQueue",e)}catch(n){throw new o(`Failed to remove item ${e} from sync queue`,"removeFromSyncQueue",n)}}async incrementSyncRetries(e){try{const n=await this.getDB(),s=await n.get("syncQueue",e);s&&(s.retries+=1,await n.put("syncQueue",s))}catch(n){throw new o(`Failed to increment retries for item ${e}`,"incrementSyncRetries",n)}}async clearSyncQueue(){try{await(await this.getDB()).clear("syncQueue")}catch(e){throw new o("Failed to clear sync queue","clearSyncQueue",e)}}async getSyncQueueCount(){try{return await(await this.getDB()).count("syncQueue")}catch(e){throw new o("Failed to get sync queue count","getSyncQueueCount",e)}}async setProgressCache(e,n,s=60){try{const r=await this.getDB(),a=new Date,i=new Date(a.getTime()+s*60*1e3),u={data:n,cachedAt:a,expiresAt:i};await r.put("progressCache",u,e)}catch(r){throw new o(`Failed to set progress cache for ${e}`,"setProgressCache",r)}}async getProgressCache(e){try{return await(await this.getDB()).get("progressCache",e)}catch(n){throw new o(`Failed to get progress cache for ${e}`,"getProgressCache",n)}}async isProgressCacheExpired(e){try{const n=await this.getProgressCache(e);return n?new Date>n.expiresAt:!0}catch(n){throw new o(`Failed to check cache expiration for ${e}`,"isProgressCacheExpired",n)}}async getValidProgressCache(e){try{const n=await this.getProgressCache(e);return n?new Date>n.expiresAt?(await this.clearProgressCache(e),null):n.data:null}catch(n){throw new o(`Failed to get valid progress cache for ${e}`,"getValidProgressCache",n)}}async clearProgressCache(e){try{await(await this.getDB()).delete("progressCache",e)}catch(n){throw new o(`Failed to clear progress cache for ${e}`,"clearProgressCache",n)}}async clearAllProgressCache(){try{await(await this.getDB()).clear("progressCache")}catch(e){throw new o("Failed to clear all progress cache","clearAllProgressCache",e)}}async setPreference(e,n){try{const s=await this.getDB(),r={key:e,value:n};await s.put("preferences",r)}catch(s){throw new o(`Failed to set preference ${e}`,"setPreference",s)}}async getPreference(e){try{return(await(await this.getDB()).get("preferences",e))?.value}catch(n){throw new o(`Failed to get preference ${e}`,"getPreference",n)}}async getAllPreferences(){try{const n=await(await this.getDB()).getAll("preferences"),s={};for(const r of n)s[r.key]=r.value;return s}catch(e){throw new o("Failed to get all preferences","getAllPreferences",e)}}async removePreference(e){try{await(await this.getDB()).delete("preferences",e)}catch(n){throw new o(`Failed to remove preference ${e}`,"removePreference",n)}}async clearPreferences(){try{await(await this.getDB()).clear("preferences")}catch(e){throw new o("Failed to clear preferences","clearPreferences",e)}}}const y=new ne;function f(t,e){return t.getTime()>e.getTime()}function se(t,e){if(t.competencyAreaId!==e.competencyAreaId||t.gradeRange!==e.gradeRange)throw new Error(`Cannot merge different competency areas: ${t.competencyAreaId} vs ${e.competencyAreaId}`);const n=Math.max(t.masteryLevel,e.masteryLevel),s=f(t.lastPracticed,e.lastPracticed)?t.lastPracticed:e.lastPracticed,r=t.totalAttempts+e.totalAttempts,a=Math.round(t.successRate/100*t.totalAttempts),i=Math.round(e.successRate/100*e.totalAttempts),u=a+i,c=r>0?u/r*100:0;let d;return t.achievedAt&&e.achievedAt?d=f(e.achievedAt,t.achievedAt)?t.achievedAt:e.achievedAt:d=t.achievedAt||e.achievedAt,{competencyAreaId:t.competencyAreaId,gradeRange:t.gradeRange,masteryLevel:n,totalAttempts:r,successRate:c,lastPracticed:s,achievedAt:d}}function re(t,e){if(t.skillId!==e.skillId)throw new Error(`Cannot merge different skills: ${t.skillId} vs ${e.skillId}`);const n=Math.max(t.masteryLevel,e.masteryLevel),s=f(t.lastPracticed,e.lastPracticed)?t.lastPracticed:e.lastPracticed,r=t.attempts+e.attempts,a=t.successes+e.successes,i=t.avgResponseTime*t.attempts+e.avgResponseTime*e.attempts,u=r>0?i/r:0;let c=t.srsParams,d=t.nextReview;return(e.srsParams.repetitionCount>t.srsParams.repetitionCount||e.srsParams.repetitionCount===t.srsParams.repetitionCount&&f(e.lastPracticed,t.lastPracticed))&&(c=e.srsParams,d=e.nextReview),{skillId:t.skillId,masteryLevel:n,srsParams:c,attempts:r,successes:a,avgResponseTime:u,lastPracticed:s,nextReview:d}}async function ae(t){switch(t.type){case"exercise_complete":await ie(t);break;case"progress_update":await oe(t);break;case"session_end":await ce(t);break;default:const e=t;throw new Error(`Unknown sync item type: ${e.type}`)}}async function ie(t){console.log("[SyncOps] Syncing exercise completion:",t.data);const{id:e,createdAt:n,...s}=t.data;try{await F(s),console.log("[SyncOps] Exercise completion synced successfully")}catch(r){throw console.error("[SyncOps] Failed to sync exercise completion:",r),r}}async function oe(t){console.log("[SyncOps] Syncing progress update:",{userId:t.data.userId,competencyCount:t.data.competencyProgress?.length??0,skillsCount:t.data.skillsProgress?.length??0});try{await le(t.data.userId,t.data.competencyProgress,t.data.skillsProgress),console.log("[SyncOps] Progress update synced successfully")}catch(e){throw console.error("[SyncOps] Failed to sync progress update:",e),e}}async function ce(t){console.log("[SyncOps] Syncing session end:",t.data.sessionId);try{await Q(t.data.sessionId,t.data.totalExercises,t.data.correctCount,t.data.avgTimePerExerciseSeconds),console.log("[SyncOps] Session end synced successfully")}catch(e){throw console.error("[SyncOps] Failed to sync session end:",e),e}}async function le(t,e,n){if(console.log("[SyncOps] Syncing progress with conflict resolution for user:",t),e&&e.length>0){const s=[];for(const r of e)try{const a=await R(t,r.competencyAreaId,r.gradeRange);if(a){const i=se(r,a);s.push(i),console.log("[SyncOps] Merged competency:",{area:r.competencyAreaId,localMastery:r.masteryLevel,serverMastery:a.masteryLevel,mergedMastery:i.masteryLevel})}else s.push(r)}catch(a){console.warn("[SyncOps] Error fetching server competency data, using local:",a),s.push(r)}await j(t,s),console.log("[SyncOps] Competency progress synced:",s.length,"items")}if(n&&n.length>0){const s=[];for(const r of n)try{const a=await z(t,r.skillId);if(a){const i=re(r,a);s.push(i),console.log("[SyncOps] Merged skill:",{skill:r.skillId,localMastery:r.masteryLevel,serverMastery:a.masteryLevel,mergedMastery:i.masteryLevel})}else s.push(r)}catch(a){console.warn("[SyncOps] Error fetching server skill data, using local:",a),s.push(r)}await N(t,s),console.log("[SyncOps] Skills progress synced:",s.length,"items")}}const ue={maxQueueSize:1e3,maxRetries:3,syncDebounceMs:2e3,initialRetryDelayMs:1e3,autoSync:!0};class de{config;isOnline;isSyncing;syncDebounceTimer=null;eventListeners=new Set;initialized=!1;constructor(e={}){this.config={...ue,...e},this.isOnline=typeof navigator<"u"?navigator.onLine:!0,this.isSyncing=!1}async initialize(){if(this.initialized){console.log("[SyncManager] Already initialized");return}console.log("[SyncManager] Initializing..."),await y.init(),typeof window<"u"&&(window.addEventListener("online",this.handleOnline),window.addEventListener("offline",this.handleOffline),document.addEventListener("visibilitychange",this.handleVisibilityChange)),this.isOnline=typeof navigator<"u"?navigator.onLine:!0,console.log("[SyncManager] Initial connection status:",this.isOnline?"online":"offline"),this.emitEvent({type:"network-change",timestamp:new Date}),this.isOnline&&this.config.autoSync&&await this.debouncedSync(),this.initialized=!0,console.log("[SyncManager] Initialized successfully")}destroy(){typeof window<"u"&&(window.removeEventListener("online",this.handleOnline),window.removeEventListener("offline",this.handleOffline),document.removeEventListener("visibilitychange",this.handleVisibilityChange)),this.syncDebounceTimer&&clearTimeout(this.syncDebounceTimer),this.eventListeners.clear(),this.initialized=!1,console.log("[SyncManager] Destroyed")}handleOnline=async()=>{console.log("[SyncManager] Connection restored"),this.isOnline=!0,this.emitEvent({type:"network-change",timestamp:new Date}),this.config.autoSync&&await this.debouncedSync()};handleOffline=()=>{console.log("[SyncManager] Connection lost"),this.isOnline=!1,this.emitEvent({type:"network-change",timestamp:new Date}),this.syncDebounceTimer&&(clearTimeout(this.syncDebounceTimer),this.syncDebounceTimer=null)};handleVisibilityChange=async()=>{document.visibilityState==="visible"&&this.isOnline&&this.config.autoSync&&await this.getQueueCount()>0&&(console.log("[SyncManager] Tab became visible with pending items, triggering sync"),await this.debouncedSync())};async debouncedSync(){this.syncDebounceTimer&&clearTimeout(this.syncDebounceTimer),this.syncDebounceTimer=setTimeout(async()=>{this.syncDebounceTimer=null,await this.sync()},this.config.syncDebounceMs)}getOnlineStatus(){return this.isOnline}getSyncingStatus(){return this.isSyncing}async getQueueCount(){return await y.getSyncQueueCount()}async addToQueue(e){if(await this.getQueueCount()>=this.config.maxQueueSize)throw new Error(`Sync queue is full (max ${this.config.maxQueueSize} items)`);const s=await y.addToSyncQueue(e);return console.log(`[SyncManager] Added item to queue: ${e.type} (id: ${s})`),this.isOnline&&this.config.autoSync&&await this.debouncedSync(),s}async clearQueue(){await y.clearSyncQueue(),console.log("[SyncManager] Queue cleared")}async manualSync(){if(!this.isOnline)throw new Error("Cannot sync while offline");return await this.sync()}async sync(){if(this.isSyncing)return console.log("[SyncManager] Sync already in progress, skipping"),0;if(!this.isOnline)return console.log("[SyncManager] Cannot sync while offline"),0;const e=await this.getQueueCount();if(e===0)return console.log("[SyncManager] Queue is empty, nothing to sync"),0;this.isSyncing=!0,console.log(`[SyncManager] Starting sync of ${e} items...`),this.emitEvent({type:"sync-start",timestamp:new Date,queueCount:e});let n=0,s=0,r;try{const a=await y.getAllSyncQueue();for(const i of a)try{if(i.retries>=this.config.maxRetries){console.warn(`[SyncManager] Item ${i.id} exceeded max retries (${this.config.maxRetries}), removing from queue`),await y.removeFromSyncQueue(i.id),s++,r=`Item exceeded max retries (${this.config.maxRetries})`;continue}console.log(`[SyncManager] Processing item ${i.id} (type: ${i.type}, attempt: ${i.retries+1})`),await ae(i),await y.removeFromSyncQueue(i.id),n++,console.log(`[SyncManager] Successfully synced item ${i.id}`)}catch(u){console.error(`[SyncManager] Failed to sync item ${i.id}:`,u),s++,r=u instanceof Error?u.message:"Unknown error",await y.incrementSyncRetries(i.id);const c=this.config.initialRetryDelayMs*Math.pow(2,i.retries);console.log(`[SyncManager] Will retry item ${i.id} after ${c}ms`)}}catch(a){console.error("[SyncManager] Sync process failed:",a),r=a instanceof Error?a.message:"Unknown error",this.emitEvent({type:"sync-error",timestamp:new Date,error:r})}finally{this.isSyncing=!1}return console.log(`[SyncManager] Sync complete: ${n} succeeded, ${s} failed`),s>0&&n===0?this.emitEvent({type:"sync-error",timestamp:new Date,error:r,itemsSynced:n}):this.emitEvent({type:"sync-success",timestamp:new Date,itemsSynced:n}),this.emitEvent({type:"sync-complete",timestamp:new Date,itemsSynced:n,queueCount:await this.getQueueCount()}),n}addEventListener(e){this.eventListeners.add(e)}removeEventListener(e){this.eventListeners.delete(e)}emitEvent(e){for(const n of this.eventListeners)try{n(e)}catch(s){console.error("[SyncManager] Event listener error:",s)}}}const h=new de,P=B({online:typeof navigator<"u"?navigator.onLine:!0,lastChanged:new Date}),l=B({syncing:!1,queueCount:0,lastSyncTime:null,error:null,lastSyncedCount:0});k(P,t=>t.online?"online":"offline");const we=k(l,t=>t.syncing?"syncing":t.error?"error":t.queueCount>0?"pending":t.lastSyncTime?"synced":"idle");async function me(){if(console.log("[NetworkStatus] Initializing status stores..."),await h.initialize(),$(),await L(),h.addEventListener(ye),typeof window<"u"&&setInterval(async()=>{const t=await h.getQueueCount();l.set({...l.get(),queueCount:t})},5e3),typeof window<"u")try{const t=await y.getPreference("lastSyncTime");t&&typeof t=="string"&&l.set({...l.get(),lastSyncTime:new Date(t)})}catch(t){console.warn("[NetworkStatus] Could not load last sync time:",t)}console.log("[NetworkStatus] Status stores initialized")}function $(){const t=h.getOnlineStatus();P.set({online:t,lastChanged:new Date})}async function L(){const t=h.getSyncingStatus(),e=await h.getQueueCount();l.set({...l.get(),syncing:t,queueCount:e})}function ye(t){switch(console.log("[NetworkStatus] Sync event:",t.type),t.type){case"network-change":$(),L();break;case"sync-start":l.set({...l.get(),syncing:!0,error:null});break;case"sync-success":l.set({...l.get(),syncing:!1,error:null,lastSyncTime:t.timestamp,lastSyncedCount:t.itemsSynced??0}),ge(t.timestamp);break;case"sync-error":l.set({...l.get(),syncing:!1,error:t.error??"Unknown error"});break;case"sync-complete":l.set({...l.get(),syncing:!1,queueCount:t.queueCount??0});break}}async function ge(t){try{await y.setPreference("lastSyncTime",t.toISOString())}catch(e){console.warn("[NetworkStatus] Could not persist last sync time:",e)}}async function Se(){if(!P.get().online)throw new Error("Cannot sync while offline");return await h.manualSync()}function pe(){const{lastSyncTime:t}=l.get();if(!t)return"Never";const n=new Date().getTime()-t.getTime(),s=Math.floor(n/1e3),r=Math.floor(s/60),a=Math.floor(r/60),i=Math.floor(a/24);return s<60?"Just now":r<60?`${r} minute${r>1?"s":""} ago`:a<24?`${a} hour${a>1?"s":""} ago`:`${i} day${i>1?"s":""} ago`}export{P as $,l as a,we as b,pe as g,me as i,Se as t};
