import{o as e}from"./idb.B3QPy4uZ.js";import{e as t,l as s,f as a,b as i,a as n,c as r}from"./island-dashboard.bEGyKmZ3.js";class c extends Error{constructor(e,t,s){super(`Storage error during ${t}: ${e}`),this.operation=t,this.cause=s,this.name="StorageError"}}const o=new class{dbPromise=null;async init(){if(!this.dbPromise)try{this.dbPromise=e("arithmetic-practice-offline",1,{upgrade(e,t,s,a){if(!e.objectStoreNames.contains("exercises")){const t=e.createObjectStore("exercises",{keyPath:"instance.id"});t.createIndex("generatedAt","generatedAt"),t.createIndex("used","used")}if(!e.objectStoreNames.contains("syncQueue")){const t=e.createObjectStore("syncQueue",{keyPath:"id",autoIncrement:!0});t.createIndex("timestamp","timestamp"),t.createIndex("type","type")}e.objectStoreNames.contains("progressCache")||e.createObjectStore("progressCache"),e.objectStoreNames.contains("preferences")||e.createObjectStore("preferences",{keyPath:"key"})},blocked(){},blocking(){}}),await this.dbPromise}catch(t){throw this.dbPromise=null,new c("Failed to initialize database","init",t)}}async getDB(){return this.dbPromise||await this.init(),this.dbPromise}static isAvailable(){try{return"undefined"!=typeof indexedDB}catch{return!1}}async close(){if(this.dbPromise){(await this.dbPromise).close(),this.dbPromise=null}}async clearAll(){try{const e=(await this.getDB()).transaction(["exercises","syncQueue","progressCache","preferences"],"readwrite");await Promise.all([e.objectStore("exercises").clear(),e.objectStore("syncQueue").clear(),e.objectStore("progressCache").clear(),e.objectStore("preferences").clear()]),await e.done}catch(e){throw new c("Failed to clear all stores","clearAll",e)}}async addExercise(e){try{const t=await this.getDB(),s={instance:e,generatedAt:new Date,used:!1};await t.put("exercises",s)}catch(t){throw new c(`Failed to add exercise ${e.id}`,"addExercise",t)}}async getExercise(e){try{const t=await this.getDB();return await t.get("exercises",e)}catch(t){throw new c(`Failed to get exercise ${e}`,"getExercise",t)}}async getUnusedExercises(e){try{const t=(await this.getDB()).transaction("exercises").objectStore("exercises"),s=(await t.getAll()).filter(e=>!1===e.used);return(e?s.slice(0,e):s).map(e=>e.instance)}catch(t){throw new c("Failed to get unused exercises","getUnusedExercises",t)}}async markExerciseUsed(e){try{const t=await this.getDB(),s=await t.get("exercises",e);s&&(s.used=!0,await t.put("exercises",s))}catch(t){throw new c(`Failed to mark exercise ${e} as used`,"markExerciseUsed",t)}}async clearExercises(){try{const e=await this.getDB();await e.clear("exercises")}catch(e){throw new c("Failed to clear exercises","clearExercises",e)}}async storeExercisePool(e){try{const t=(await this.getDB()).transaction("exercises","readwrite"),s=t.objectStore("exercises");for(const a of e){const e={instance:a,generatedAt:new Date,used:!1};await s.put(e)}await t.done}catch(t){throw new c(`Failed to store ${e.length} exercises`,"storeExercisePool",t)}}async getExercisePoolStats(){try{const e=await this.getDB(),t=await e.getAll("exercises"),s=t.filter(e=>!e.used).length,a=t.filter(e=>e.used).length;let i=null;if(t.length>0){const e=Math.min(...t.map(e=>e.generatedAt.getTime()));i=Math.floor((Date.now()-e)/864e5)}return{total:t.length,unused:s,used:a,oldestAge:i}}catch(e){throw new c("Failed to get pool stats","getExercisePoolStats",e)}}async cleanupOldExercises(e){try{const t=(await this.getDB()).transaction("exercises","readwrite"),s=t.objectStore("exercises"),a=s.index("generatedAt"),i=await a.getAll(IDBKeyRange.upperBound(e));for(const e of i)await s.delete(e.instance.id);return await t.done,i.length}catch(t){throw new c("Failed to cleanup old exercises","cleanupOldExercises",t)}}async clearExercisePool(){return this.clearExercises()}async getExerciseCount(){try{const e=await this.getDB(),t=await e.count("exercises"),s=await e.getAll("exercises");return{total:t,unused:s.filter(e=>!e.used).length}}catch(e){throw new c("Failed to get exercise count","getExerciseCount",e)}}async addToSyncQueue(e){try{const t=await this.getDB(),s=await t.add("syncQueue",e);return Number(s)}catch(t){throw new c("Failed to add item to sync queue","addToSyncQueue",t)}}async getAllSyncQueue(){try{const e=await this.getDB();return await e.getAll("syncQueue")}catch(e){throw new c("Failed to get all sync queue items","getAllSyncQueue",e)}}async getSyncQueueByType(e){try{const t=(await this.getDB()).transaction("syncQueue").store.index("type");return await t.getAll(e)}catch(t){throw new c(`Failed to get sync queue items of type ${e}`,"getSyncQueueByType",t)}}async removeFromSyncQueue(e){try{const t=await this.getDB();await t.delete("syncQueue",e)}catch(t){throw new c(`Failed to remove item ${e} from sync queue`,"removeFromSyncQueue",t)}}async incrementSyncRetries(e){try{const t=await this.getDB(),s=await t.get("syncQueue",e);s&&(s.retries+=1,await t.put("syncQueue",s))}catch(t){throw new c(`Failed to increment retries for item ${e}`,"incrementSyncRetries",t)}}async clearSyncQueue(){try{const e=await this.getDB();await e.clear("syncQueue")}catch(e){throw new c("Failed to clear sync queue","clearSyncQueue",e)}}async getSyncQueueCount(){try{const e=await this.getDB();return await e.count("syncQueue")}catch(e){throw new c("Failed to get sync queue count","getSyncQueueCount",e)}}async setProgressCache(e,t,s=60){try{const a=await this.getDB(),i=new Date,n=new Date(i.getTime()+60*s*1e3),r={data:t,cachedAt:i,expiresAt:n};await a.put("progressCache",r,e)}catch(a){throw new c(`Failed to set progress cache for ${e}`,"setProgressCache",a)}}async getProgressCache(e){try{const t=await this.getDB();return await t.get("progressCache",e)}catch(t){throw new c(`Failed to get progress cache for ${e}`,"getProgressCache",t)}}async isProgressCacheExpired(e){try{const t=await this.getProgressCache(e);return!t||new Date>t.expiresAt}catch(t){throw new c(`Failed to check cache expiration for ${e}`,"isProgressCacheExpired",t)}}async getValidProgressCache(e){try{const t=await this.getProgressCache(e);if(!t)return null;return new Date>t.expiresAt?(await this.clearProgressCache(e),null):t.data}catch(t){throw new c(`Failed to get valid progress cache for ${e}`,"getValidProgressCache",t)}}async clearProgressCache(e){try{const t=await this.getDB();await t.delete("progressCache",e)}catch(t){throw new c(`Failed to clear progress cache for ${e}`,"clearProgressCache",t)}}async clearAllProgressCache(){try{const e=await this.getDB();await e.clear("progressCache")}catch(e){throw new c("Failed to clear all progress cache","clearAllProgressCache",e)}}async setPreference(e,t){try{const s=await this.getDB(),a={key:e,value:t};await s.put("preferences",a)}catch(s){throw new c(`Failed to set preference ${e}`,"setPreference",s)}}async getPreference(e){try{const t=await this.getDB(),s=await t.get("preferences",e);return s?.value}catch(t){throw new c(`Failed to get preference ${e}`,"getPreference",t)}}async getAllPreferences(){try{const e=await this.getDB(),t=await e.getAll("preferences"),s={};for(const a of t)s[a.key]=a.value;return s}catch(e){throw new c("Failed to get all preferences","getAllPreferences",e)}}async removePreference(e){try{const t=await this.getDB();await t.delete("preferences",e)}catch(t){throw new c(`Failed to remove preference ${e}`,"removePreference",t)}}async clearPreferences(){try{const e=await this.getDB();await e.clear("preferences")}catch(e){throw new c("Failed to clear preferences","clearPreferences",e)}}};function l(e,t){return e.getTime()>t.getTime()}function h(e,t){if(e.competencyAreaId!==t.competencyAreaId||e.gradeRange!==t.gradeRange)throw new Error(`Cannot merge different competency areas: ${e.competencyAreaId} vs ${t.competencyAreaId}`);const s=Math.max(e.masteryLevel,t.masteryLevel),a=l(e.lastPracticed,t.lastPracticed)?e.lastPracticed:t.lastPracticed,i=e.totalAttempts+t.totalAttempts,n=Math.round(e.successRate/100*e.totalAttempts),r=Math.round(t.successRate/100*t.totalAttempts),c=i>0?(n+r)/i*100:0;let o;return o=e.achievedAt&&t.achievedAt?l(t.achievedAt,e.achievedAt)?e.achievedAt:t.achievedAt:e.achievedAt||t.achievedAt,{competencyAreaId:e.competencyAreaId,gradeRange:e.gradeRange,masteryLevel:s,totalAttempts:i,successRate:c,lastPracticed:a,achievedAt:o}}function u(e,t){if(e.skillId!==t.skillId)throw new Error(`Cannot merge different skills: ${e.skillId} vs ${t.skillId}`);const s=Math.max(e.masteryLevel,t.masteryLevel),a=l(e.lastPracticed,t.lastPracticed)?e.lastPracticed:t.lastPracticed,i=e.attempts+t.attempts,n=e.successes+t.successes,r=e.avgResponseTime*e.attempts+t.avgResponseTime*t.attempts,c=i>0?r/i:0;let o=e.srsParams,h=e.nextReview;return(t.srsParams.repetitionCount>e.srsParams.repetitionCount||t.srsParams.repetitionCount===e.srsParams.repetitionCount&&l(t.lastPracticed,e.lastPracticed))&&(o=t.srsParams,h=t.nextReview),{skillId:e.skillId,masteryLevel:s,srsParams:o,attempts:i,successes:n,avgResponseTime:c,lastPracticed:a,nextReview:h}}async function d(e){switch(e.type){case"exercise_complete":await async function(e){const{id:t,createdAt:a,...i}=e.data;try{await s(i)}catch(n){throw n}}(e);break;case"progress_update":await async function(e){try{await async function(e,t,s){if(t&&t.length>0){const s=[];for(const i of t)try{const t=await a(e,i.competencyAreaId,i.gradeRange);if(t){const e=h(i,t);s.push(e)}else s.push(i)}catch(c){s.push(i)}await i(e,s)}if(s&&s.length>0){const t=[];for(const a of s)try{const s=await n(e,a.skillId);if(s){const e=u(a,s);t.push(e)}else t.push(a)}catch(c){t.push(a)}await r(e,t)}}(e.data.userId,e.data.competencyProgress,e.data.skillsProgress)}catch(t){throw t}}(e);break;case"session_end":await async function(e){try{await t(e.data.sessionId,e.data.totalExercises,e.data.correctCount,e.data.avgTimePerExerciseSeconds)}catch(s){throw s}}(e);break;default:throw new Error(`Unknown sync item type: ${e.type}`)}}const y={maxQueueSize:1e3,maxRetries:3,syncDebounceMs:2e3,initialRetryDelayMs:1e3,autoSync:!0};const w=new class{config;isOnline;isSyncing;syncDebounceTimer=null;eventListeners=new Set;initialized=!1;constructor(e={}){this.config={...y,...e},this.isOnline="undefined"==typeof navigator||"boolean"!=typeof navigator.onLine||navigator.onLine,this.isSyncing=!1}async initialize(){this.initialized||(await o.init(),"undefined"!=typeof window&&(window.addEventListener("online",this.handleOnline),window.addEventListener("offline",this.handleOffline),document.addEventListener("visibilitychange",this.handleVisibilityChange)),this.isOnline="undefined"==typeof navigator||"boolean"!=typeof navigator.onLine||navigator.onLine,this.emitEvent({type:"network-change",timestamp:new Date}),this.isOnline&&this.config.autoSync&&await this.debouncedSync(),this.initialized=!0)}destroy(){"undefined"!=typeof window&&(window.removeEventListener("online",this.handleOnline),window.removeEventListener("offline",this.handleOffline),document.removeEventListener("visibilitychange",this.handleVisibilityChange)),this.syncDebounceTimer&&clearTimeout(this.syncDebounceTimer),this.eventListeners.clear(),this.initialized=!1}handleOnline=async()=>{this.isOnline=!0,this.emitEvent({type:"network-change",timestamp:new Date}),this.config.autoSync&&await this.debouncedSync()};handleOffline=()=>{this.isOnline=!1,this.emitEvent({type:"network-change",timestamp:new Date}),this.syncDebounceTimer&&(clearTimeout(this.syncDebounceTimer),this.syncDebounceTimer=null)};handleVisibilityChange=async()=>{if("visible"===document.visibilityState&&this.isOnline&&this.config.autoSync){await this.getQueueCount()>0&&await this.debouncedSync()}};async debouncedSync(){this.syncDebounceTimer&&clearTimeout(this.syncDebounceTimer),this.syncDebounceTimer=setTimeout(async()=>{this.syncDebounceTimer=null,await this.sync()},this.config.syncDebounceMs)}getOnlineStatus(){return this.isOnline}getSyncingStatus(){return this.isSyncing}async getQueueCount(){return await o.getSyncQueueCount()}async addToQueue(e){if(await this.getQueueCount()>=this.config.maxQueueSize)throw new Error(`Sync queue is full (max ${this.config.maxQueueSize} items)`);const t=await o.addToSyncQueue(e);return this.isOnline&&this.config.autoSync&&await this.debouncedSync(),t}async clearQueue(){await o.clearSyncQueue()}async manualSync(){if(!this.isOnline)throw new Error("Cannot sync while offline");return await this.sync()}async sync(){if(this.isSyncing)return 0;if(!this.isOnline)return 0;const e=await this.getQueueCount();if(0===e)return 0;this.isSyncing=!0,this.emitEvent({type:"sync-start",timestamp:new Date,queueCount:e});let t,s=0,a=0;try{const e=await o.getAllSyncQueue();for(const n of e)try{if(n.retries>=this.config.maxRetries){await o.removeFromSyncQueue(n.id),a++,t=`Item exceeded max retries (${this.config.maxRetries})`;continue}await d(n),await o.removeFromSyncQueue(n.id),s++}catch(i){a++,t=i instanceof Error?i.message:"Unknown error",await o.incrementSyncRetries(n.id);this.config.initialRetryDelayMs,Math.pow(2,n.retries)}}catch(i){t=i instanceof Error?i.message:"Unknown error",this.emitEvent({type:"sync-error",timestamp:new Date,error:t})}finally{this.isSyncing=!1}return a>0&&0===s?this.emitEvent({type:"sync-error",timestamp:new Date,error:t,itemsSynced:s}):this.emitEvent({type:"sync-success",timestamp:new Date,itemsSynced:s}),this.emitEvent({type:"sync-complete",timestamp:new Date,itemsSynced:s,queueCount:await this.getQueueCount()}),s}addEventListener(e){this.eventListeners.add(e)}removeEventListener(e){this.eventListeners.delete(e)}emitEvent(e){for(const s of this.eventListeners)try{s(e)}catch(t){}}};export{o,w as s};
