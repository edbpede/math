/**
 * Sync Operations
 *
 * Handles synchronization of different queue item types to Supabase.
 * Implements conflict resolution for progress updates.
 *
 * Requirements:
 * - 6.4: Automatic background sync when connection restored
 * - 6.5: Conflict resolution with last-write-wins and max mastery
 */

import {
    logExerciseAttempt,
    batchUpdateCompetencyProgress,
    batchUpdateSkillProgress,
    endSession,
    fetchCompetencyProgressByArea,
    fetchSkillProgressBySkill,
} from "../supabase/progress";
import {
    mergeCompetencyProgress,
    mergeSkillProgress,
} from "./conflict-resolution";
import type {
    SyncQueueItem,
    ExerciseCompleteSyncItem,
    ProgressUpdateSyncItem,
    SessionEndSyncItem,
} from "./types";
import type { CompetencyProgress, SkillProgress } from "../mastery/types";

/**
 * Sync a single queue item based on its type
 *
 * Uses discriminated union pattern for type-safe handling.
 *
 * @param item - Queue item to sync
 * @throws Error if sync fails
 */
export async function syncQueueItem(item: SyncQueueItem): Promise<void> {
    switch (item.type) {
        case "exercise_complete":
            await syncExerciseComplete(item);
            break;
        case "progress_update":
            await syncProgressUpdate(item);
            break;
        case "session_end":
            await syncSessionEnd(item);
            break;
        default:
            // TypeScript will error if we miss a case
            const _exhaustiveCheck: never = item;
            throw new Error(
                `Unknown sync item type: ${(_exhaustiveCheck as SyncQueueItem).type}`,
            );
    }
}

/**
 * Sync exercise completion to history table
 *
 * Exercise history is append-only, so no conflict resolution is needed.
 * We just log the attempt to the server.
 *
 * @param item - Exercise complete sync item
 * @throws Error if logging fails
 */
async function syncExerciseComplete(
    item: ExerciseCompleteSyncItem,
): Promise<void> {
    console.log("[SyncOps] Syncing exercise completion:", item.data);

    // Remove the id and createdAt fields as they will be generated by the server
    const { id, createdAt, ...attemptData } = item.data;

    try {
        await logExerciseAttempt(attemptData);
        console.log("[SyncOps] Exercise completion synced successfully");
    } catch (error) {
        console.error("[SyncOps] Failed to sync exercise completion:", error);
        throw error;
    }
}

/**
 * Sync progress updates with conflict resolution
 *
 * Fetches current server data, merges with local changes using conflict
 * resolution rules, then updates server with merged data.
 *
 * @param item - Progress update sync item
 * @throws Error if sync fails
 */
async function syncProgressUpdate(item: ProgressUpdateSyncItem): Promise<void> {
    console.log("[SyncOps] Syncing progress update:", {
        userId: item.data.userId,
        competencyCount: item.data.competencyProgress?.length ?? 0,
        skillsCount: item.data.skillsProgress?.length ?? 0,
    });

    try {
        // Use the complete sync function with conflict resolution
        await syncProgressUpdateWithConflictResolution(
            item.data.userId,
            item.data.competencyProgress,
            item.data.skillsProgress,
        );

        console.log("[SyncOps] Progress update synced successfully");
    } catch (error) {
        console.error("[SyncOps] Failed to sync progress update:", error);
        throw error;
    }
}

/**
 * Sync session end
 *
 * Updates the session record with final statistics.
 *
 * @param item - Session end sync item
 * @throws Error if update fails
 */
async function syncSessionEnd(item: SessionEndSyncItem): Promise<void> {
    console.log("[SyncOps] Syncing session end:", item.data.sessionId);

    try {
        await endSession(
            item.data.sessionId,
            item.data.totalExercises,
            item.data.correctCount,
            item.data.avgTimePerExerciseSeconds,
        );
        console.log("[SyncOps] Session end synced successfully");
    } catch (error) {
        console.error("[SyncOps] Failed to sync session end:", error);
        throw error;
    }
}

/**
 * Sync progress updates with full conflict resolution
 *
 * This is a more complete version that properly handles conflict resolution.
 * It requires userId to be passed in the sync context.
 *
 * @param userId - User UUID
 * @param localCompetency - Local competency progress updates
 * @param localSkills - Local skills progress updates
 * @throws Error if sync fails
 */
export async function syncProgressUpdateWithConflictResolution(
    userId: string,
    localCompetency?: CompetencyProgress[],
    localSkills?: SkillProgress[],
): Promise<void> {
    console.log(
        "[SyncOps] Syncing progress with conflict resolution for user:",
        userId,
    );

    // Sync competency progress
    if (localCompetency && localCompetency.length > 0) {
        const mergedCompetency: CompetencyProgress[] = [];

        for (const local of localCompetency) {
            try {
                // Fetch current server data
                const serverData = await fetchCompetencyProgressByArea(
                    userId,
                    local.competencyAreaId,
                    local.gradeRange,
                );

                if (serverData) {
                    // Server has data - merge with local
                    const merged = mergeCompetencyProgress(local, serverData);
                    mergedCompetency.push(merged);
                    console.log("[SyncOps] Merged competency:", {
                        area: local.competencyAreaId,
                        localMastery: local.masteryLevel,
                        serverMastery: serverData.masteryLevel,
                        mergedMastery: merged.masteryLevel,
                    });
                } else {
                    // No server data - use local
                    mergedCompetency.push(local);
                }
            } catch (error) {
                console.warn(
                    "[SyncOps] Error fetching server competency data, using local:",
                    error,
                );
                mergedCompetency.push(local);
            }
        }

        // Batch update
        await batchUpdateCompetencyProgress(userId, mergedCompetency);
        console.log(
            "[SyncOps] Competency progress synced:",
            mergedCompetency.length,
            "items",
        );
    }

    // Sync skills progress
    if (localSkills && localSkills.length > 0) {
        const mergedSkills: SkillProgress[] = [];

        for (const local of localSkills) {
            try {
                // Fetch current server data
                const serverData = await fetchSkillProgressBySkill(
                    userId,
                    local.skillId,
                );

                if (serverData) {
                    // Server has data - merge with local
                    const merged = mergeSkillProgress(local, serverData);
                    mergedSkills.push(merged);
                    console.log("[SyncOps] Merged skill:", {
                        skill: local.skillId,
                        localMastery: local.masteryLevel,
                        serverMastery: serverData.masteryLevel,
                        mergedMastery: merged.masteryLevel,
                    });
                } else {
                    // No server data - use local
                    mergedSkills.push(local);
                }
            } catch (error) {
                console.warn(
                    "[SyncOps] Error fetching server skill data, using local:",
                    error,
                );
                mergedSkills.push(local);
            }
        }

        // Batch update
        await batchUpdateSkillProgress(userId, mergedSkills);
        console.log(
            "[SyncOps] Skills progress synced:",
            mergedSkills.length,
            "items",
        );
    }
}
